from ..utils import format
from pathlib import Path
from .. import config
import numpy as np
import os
import re

class Cluster:

    def __init__(self, filename):
        '''
            Performs operations on saved cluster data, as generated by the
            functions in:

                    /src/backend/preprocessing/clusters.py
        '''
        self.path = config.clusters_relpath / filename
        self.data = tuple(self.path.glob('*'))

        # Finding expected prefix and number of digits in directory names
        pat1 = r'(.*)\{:0(\d{1})d\}'
        matches = re.findall(pat1, config.cluster_dir_labels)[0]
        self.prefix = matches[0]
        self.N_digs = int(matches[1])

        self.verify_integrity()
        self.clusters = self.map_clusters()


    def verify_integrity(self):
        '''
            Confirms that each directory contains the expected files and
            file contents.
        '''
        expected = format.I(self.prefix + 'X'*self.N_digs)
        msg = ('Directory {} is of invalid format, expected name to take '
               f'format {expected}, where {format.I("X")} is a digit.')
        numbers = []

        # Confirming that each directory is correctly labeled
        for f in self.data:
            path = f.parts[-1]
            pat2 = f'.*{self.prefix}\d{{{self.N_digs}}}'
            if len(re.findall(pat2, path)) != 1:
                raise FileNotFoundError(msg.format(format.I(path)))
            pat3 = f'.*{self.prefix}(\d{{{self.N_digs}}})'
            numbers.append(int(re.findall(pat3, path)[0]))

        msg = 'Non-sequential directories discovered, data likely corrupted.'
        if sorted(numbers) != list(range(0, len(self.data), 1)):
            raise FileNotFoundError(msg)

        # Confirming that each directory contains expected files
        msg = 'Missing datafile {}.'
        for f in self.data:
            datafiles = []
            for i in f.glob('*'):
                datafiles.append(i.parts[-1])
            if config.cluster_data not in datafiles:
                expected = f / config.cluster_data
                raise FileNotFoundError(msg.format(format.I(expected)))
            if config.cluster_metadata not in datafiles:
                expected = f / config.cluster_metadata
                raise FileNotFoundError(msg.format(format.I(expected)))

    def map_clusters(self):
        '''
            Creates a dict that can be used to identify clusters and manipulate
            their contents.
        '''
        clusters = {}
        for f in self.data:
            pat = f'.*{self.prefix}(\d{{{self.N_digs}}})'
            label = int(re.findall(pat, f.parts[-1])[0])
            print(label)

        return clusters

    def parse_data(self):
        '''
            Generator that parses through each cluster's data.
        '''
        pass
